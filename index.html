<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Digit Classifier</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #000; margin-top: 10px; }
    button { margin-top: 10px; padding: 10px 20px; font-size: 16px; }
  </style>
</head>
<body>

  <h1>Draw a Digit (0-9)</h1>
  <canvas id="canvas" width="280" height="280"></canvas><br>
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="predictDigit()">Predict</button>

  <h2 id="result">Prediction: ?</h2>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  let isDrawing = false;

  // Soporte para mouse
  canvas.addEventListener('mousedown', () => { isDrawing = true });
  canvas.addEventListener('mouseup', () => { isDrawing = false; ctx.beginPath() });
  canvas.addEventListener('mousemove', drawMouse);

  // Soporte para tÃ¡ctil
  canvas.addEventListener('touchstart', (e) => {
    isDrawing = true;
    drawTouch(e);
  }, { passive: false });

  canvas.addEventListener('touchend', () => {
    isDrawing = false;
    ctx.beginPath();
  });

  canvas.addEventListener('touchmove', drawTouch, { passive: false });

  function drawMouse(e) {
    if (!isDrawing) return;
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'black';
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(e.offsetX, e.offsetY);
  }

  function drawTouch(e) {
    e.preventDefault(); // Evita que la pantalla se desplace mientras se dibuja
    if (!isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'black';
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    document.getElementById("result").innerText = "Prediction: ?";
  }

  async function predictDigit() {
    const smallCanvas = document.createElement('canvas');
    smallCanvas.width = 28;
    smallCanvas.height = 28;
    const smallCtx = smallCanvas.getContext('2d');
    smallCtx.drawImage(canvas, 0, 0, 28, 28);
    const imgData = smallCtx.getImageData(0, 0, 28, 28);

    const pixels = [];
    for (let i = 0; i < imgData.data.length; i += 4) {
      const r = imgData.data[i]; // Grayscale assumed (R=G=B)
      const norm = (255 - r) / 255;
      pixels.push(norm);
    }

    const response = await fetch("https://mnistapp-rtov.onrender.com/predict", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ pixels: pixels })
    });

    const result = await response.json();
    document.getElementById("result").innerText = "Prediction: " + result.prediction;
  }
</script>

</body>
</html>
